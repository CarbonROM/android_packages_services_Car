/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.automotive.computepipe.runner@1.0;

import android.automotive.computepipe@1.0::PipeStatus;
import IPipeStateHandler;
import IPipeStream;
import IPipeDebugger;

interface IPipeRunner {
    /**
     * Returns the descriptor for the associated mediapipe
     *
     * @return A descriptor that describes the input options, offload options
     * and the outputstreams of a media pipe instance.
     */
    getPipeDescriptor() generates (PipeDescriptor desc);

    /**
     * Set the input source for the mediapipe graph.
     * This should be done prior to invoking startMediaPipe.
     *
     * @param configId id selected from the available input options.
     * @return if selection of input source was supported returns OK
     */
    setPipeInputSource(uint32_t configId) generates (PipeStatus status);

    /**
     * Set the offload options for a graph.
     * This should be a subset of the supported offload options present in the
     * descriptor. This should be done prior to invoking startMediaPipe
     *
     * @param configID offload option id from the advertised offload options.
     * @return if offload option was set then returns OK.
     */
    setPipeOffloadOptions(uint32_t configId) generates (PipeStatus status);

    /**
     * Set the termination options for a graph.
     * This should be a subset of the supported termination options present in the
     * descriptor. This should be done prior to invoking startMediaPipe.
     * If this step is not performed then it is assumed the client will
     * stop pipe using stopPipe().
     *
     * @param terminationId id of the supported termination option as advertized
     * in the pipe descriptor
     * @return if termination criteria was supported then returns OK.
     */
    setPipeTermination(uint32_t configId) generates (PipeStatus status);

    /**
     * Set the state notification callback.
     * This callback will be triggered to notify the client about the state
     * transitions of a graph.
     * This should be invoked prior to calling startMediaPipe or any other
     * setPipe*() methods.
     *
     * @param: stateHandler that is a callback to notify client about graph
     * state
     * @return OK PipeStatus if setting state handler was successful
     */
    setPipeStateNotifier(IPipeStateHandler stateHandler) generates (PipeStatus status);

    /**
     * Enable a output stream and install call back for packets from that
     * stream. This should be invoked prior to calling startMediaPipe.
     * Call this for each output stream that a client wants to enable
     *
     * @param configId: describes the output stream configuration the client
     * wants to enable
     * @param maxInFlightCount: The maximum number of inflight packets the
     * client can handle.
     * @param handler: the handler for the output packets to be invoked once
     * packet is received
     * @return OK PipeStatus if setting callback succeeded
     */
    setPipeOutputConfig(uint32_t configId, uint32_t maxInFlightCount, IPipeStream handler)
        generates (PipeStatus status);

    /**
     * Start Mediapipe execution on the runner. Prior to this step
     * each of the configuration steps should be completed. Once the
     * configurations have been applied the state handler will be invoked with
     * the PipeState::CONFIG_DONE notification. Wait for this notification before starting the PIPE.
     * Once the Pipe starts execution the client will receive the state
     * notification PipeState::RUNNING through IPipeStateHandler::handleState
     *
     * @return OK PipeStatus if start succeeded.
     */
    startPipe() generates (PipeStatus status);

    /**
     * Stop Mediapipe execution on the runner.
     *
     * This can invoked only when the pipe is run state ie PipeState::RUNNING.
     * If a client has already chosen a termination option, then this
     * call overrides that termination criteria.
     *
     * Client will be notified once the pipe has stopped.
     * Until then, outstanding packets may continue to be received.
     * These packets must still be returned with doneWithPacket().
     *
     * Once the Pipe stops execution (no new packets generated),
     * the client will receive the state
     * notification, PipeState::DONE, through IPipeStateHandler::handleState.
     *
     * Once the pipe has completely quiesced, it will transition back to
     * PipeState::CONFIG_DONE and at this point a new startPipe() can be issued.
     *
     *
     * @return OK PipeStatus if stop succeeded
     */
    stopPipe() generates (PipeStatus status);

    /**
     * Signal completion of a packet having been consumed by the client.
     * With this signal from client the runner should release buffer corresponding to the packet.
     *
     * @param id packet id
     * @return OK PipeStatus if successful
     */
    doneWithPacket(uint32_t id) generates (PipeStatus status);

    /**
     * Returns the debugger associated with the runner for this graph
     *
     * @return Debugger handle to interact with specific graph
     */
    getPipeDebugger() generates (IPipeDebugger debugger);

    /**
     * Immediately frees up all config resources associated with the client.
     * Client will not receive state notifications after this call is complete.
     *
     * This will also free up any in flight packet.
     * The client may still get in flight IPipeStream::deliverPacket() callbacks.
     * However the underlying buffer has been freed up from the packets.
     *
     * This also resets any configuration that a client may have performed,
     * ie pipe transitions back to PipeState::RESET state.
     * So client will have to start next session with
     * the configuration steps, ie invoke setPipe*() methods.
     *
     * If the client had chosen to enable profiling through IPipeDebugger,
     * the client should first invoke IPipeDebugger::Release() prior to
     * this method.
     *
     * @return status OK if all resources were freed up.
     */
    releaseRunner() generates (PipeStatus status);
};
